## 跨域
跨域：接口请求的地址和当前页面的地址如果协议、域名、端口其中有一项不同，就说该接口跨域
原因：浏览器为了保证网页的安全，出的同源协议策略。

当浏览器发现请求是跨域的时候，它会做一些校验，如果校验不通过它就会报跨域安全错误
 

发送的是 XHR(XMLHttpRequest) 请求，如果发送的不是XHR请求，就算是跨域，浏览器也不会报错（XHR/CORS、Fetch、WebSocket）


浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）
浏览器在发送跨域请求的时候，会先判断跨域是简单请求还是非简单请求，如果是简单请求它会先执行，后判断。如果是非简单请求，会发一个OPTIONS的预检命令，检查通过后，他会把真正的请求发送过去。

请求一定是先发出去，在返回来的时候被浏览器拦截了，如果请求是有返回值的，会被浏览器隐藏掉

## 预检请求
作用就是服务端是不是允许这次请求，如果当前请求是个跨域的请求，你可以理解为：询问服务端是不是允许请求在当前域下跨域发送。它还有其他的作用，比如 询问 服务端支持哪些 HTTP 方法。

当预检请求到达服务端时，服务端是不会真正执行这个请求的逻辑的，只会在这个请求上返回一些 HTTP Header，以此来告诉客户端是不是要发送真正的请求

如果你发送的是一个简单请求，这个请求不管是不是会受到跨域的限制，只要发出去了，一定会在服务端被执行，浏览器只是隐藏了返回值而已。

总结下要点：

1、简单请求：不管是否跨域，只要发出去了，一定会到达服务端并被执行，浏览器只会隐藏返回值

2、复杂请求：先发预检，预检不会真正执行业务逻辑，预检通过后才会发送真正请求并在服务端被执行

## 跨域解决方案
1. cors：目前最常用的一种解决办法，通过设置后端允许跨域实现。
res.setHeader('Access-Control-Allow-Origin', '*');
res.setHeader("Access-Control-Allow-Methods", "GET, PUT, OPTIONS, POST");

2. node中间件、nginx反向代理：跨域限制的时候浏览器不能跨域访问服务器，node中间件和nginx反向代理，都是让请求发给代理服务器，静态页面面和代理服务器是同源的，然后代理服务器再向后端服务器发请求，服务器和服务器之间不存在同源限制。

3. JSONP：利用的原理是script标签不受同源影响，创建一个script标签, 再把需要请求的api地址放到src里. 这个请求只能用GET方法，不能解决 不同域的两个页面之间js调用的问题

get链接上发送回调函数名称 传给服务器 服务器获取回调函数名称 返回这个函数名称的JS函数（拼装函数） json数据作为函数的实际参数传入 返回的数据是js函数  在前端调用回调函数（ json数据传入） 执行回调函数

4. postmessage：H5新增API，通过发送和接收API实现跨域通信。

5. 设置proxy

## 什么是cors
是一个 W3C 标准，全称是"跨域资源共享" Cross-origin resource sharing


CORS需要浏览器和服务器同时支持。但是目前基本上浏览器都支持，所以我们只要保证服务器端服务器实现了 CORS 接口，就可以跨源通信。

浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）

## cors相关的常用的请求头有哪些
（access-control-request-headers、access-control-request-method、Access-Control-Allow-origin）