程序执行过程中可能会产生一些之后用不到的数据，会一直保存在内存当中，需要垃圾回收机制帮我清理这些用不到的变量，常见方法两种
1. 标记清除法：从根元素开始，周期性标记可被访问的对象，同时回收不可被访问的对象。问题：收集垃圾时程序会等待，且回收后的内存空间不连续，于是出现了 标记-整理机制，即回收后会整理内存空间，但效率又会降低一些

2. 引用计数法：检测到一个对象没有引用指向他，gc就会回收
3. 分代收集、
4. 增量收集

## 引发内存泄漏的场景

1. 监听的事件没有解绑

2. 互相引用  a指向b b指向a

3. 闭包

4. 数组复用 arr.length = 0, 对象复用 a = null

5. Vue中$store, watch之后没有unwatch

垃圾回收（Garbage Collection，简称 GC）是一种自动管理内存的机制，它会自动检测不再使用的对象并释放它们所占用的内存。在 JavaScript 中，垃圾回收器会定期运行，以确保释放不再使用的对象的内存。以下是一些常见的垃圾回收算法：

引用计数（Reference Counting）：这种垃圾回收算法跟踪每个对象的引用次数。当引用次数为零时，对象被认为是不可访问的，因此可以被回收。然而，引用计数算法存在一个问题，即循环引用。当两个对象互相引用时，它们的引用计数永远不会降为零，因此无法被回收，导致内存泄漏。

举例：假设有两个对象 A 和 B，它们互相引用。

```javascript
let A = {ref: null};
let B = {ref: null};
A.ref = B;
B.ref = A;

```


现在将 A 和 B 设置为 null，尽管它们不再可访问，但由于它们的引用计数仍然为 1，因此无法被回收。

标记-清除（Mark and Sweep）：这种垃圾回收算法分为两个阶段。在标记阶段，垃圾回收器从根对象（如全局对象）开始，遍历所有可访问的对象，并将它们标记为活动对象。在清除阶段，垃圾回收器遍历所有对象，将未被标记的对象（即不可访问的对象）回收。这种算法解决了引用计数算法的循环引用问题。

举例：假设有两个对象 A 和 B，它们互相引用，并且不再可访问。

```javascript
(function() {
  let A = {ref: null};
  let B = {ref: null};
  A.ref = B;
  B.ref = A;
})();

```


在标记-清除算法中，由于 A 和 B 不再可访问，它们不会被标记为活动对象。因此，在清除阶段，垃圾回收器会释放 A 和 B 占用的内存。

JavaScript 引擎通常使用标记-清除算法作为主要的垃圾回收方法，但也可能结合其他算法（如分代收集、增量收集等）来优化垃圾回收性能。需要注意的是，垃圾回收器的实现和运行时机是由 JavaScript 引擎决定的，开发者无法直接控制。因此，在编写代码时，我们应该尽量避免产生不必要的全局变量和循环引用，以减轻垃圾回收器的负担。