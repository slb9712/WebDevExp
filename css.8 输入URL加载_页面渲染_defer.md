
  
  1、浏览器输入URL发生了什么？
  
     1、输入url进行查找
     2、浏览器查找当前URL缓存，如果有缓存直接返回给页面，没有缓存则进入网络请求。
     3、DNS解析URL对应的IP地址。（从根域服务器，再向顶级域，二层域最后子域，然后一级一级最后找到域名地址）
     4、根据IP建立TCP(传输控制协议)连接（三次握手）。
     5、合成请求头信息，发起HTTP请求。
     6、服务器处理请求，浏览器接收HTTP响应。
     7、关闭TCP连接（四次挥手）。
     8、构建DOM树，浏览器渲染页面。
 



  根据问题1 衍生问题2问题3
  2、三次握手、四次挥手
  确保建立可靠连接 避免资源浪费
     第一次握手： 建立连接时，客户端发送syn包 连接请求 （syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认； 
     第二次握手： 服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包  确认报文，此时服务器进入SYN_RECV状态；
     第三次握手： 客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。
  
     第三次握手是为了防止已经失效的连接请求报文段突然又传到服务端，防止重复连接
 


 3、浏览器如何渲染页面的？
     1、解析文档构建dom树
     js会交给js引擎处理，css会交给CSS解析器处理。正常情况下， html解析器和css解析器同时进行解析, html解析成一个dom树，解析成dom树的同时，css解析器也会解析成一个css 规则树（ CSSOM ）。在 head 中遇到 JS 文件时，HTML 的解析会停 下来，等 JS 文件下载结束并且执行完，HTML 的解析工作再接着来，防止 JS 修改已经完成的解析结果。
     
           1、HTML 被 HTML 解析器解析成 DOM 树；
           2、CSS：解析样式表，生成CSS规则树
           3、JavaScript：解析脚本，通过DOM API和CSSOM API操作DOM Tree和CSS Rule Tree，与用户进行交互
     2、构建渲染树
           解析文档完成后，浏览器引擎会将 CSS Rule Tree 附着到DOM Tree 上，并根据DOM Tree 和 CSS Rule Tree构造 Rendering Tree（渲染树）
     3、布局与绘制渲染树
           浏览器从服务器获取文档并从上到下进行解析，不包含defer和async属性的情况下，按下面执行
##
           1、解析html文档，遇到HTML标签时，构建DOM树
           2、在构建DOM的过程中，如果遇到外联的样式声明或脚本声明，则暂停文档解析，创建新的网络连接，开始下载样式文件和脚本文件
           3、样式文件下载完成后，构建CSS Rule DOM，脚本文件下载完成后，解释并立即执行。
           4、构建DOM的同时，结合CSS规则树生成渲染树，接着进入布局，遍历生成的 DOM 树节点，并把他们添加到布局树中。浏览器通过解析计算出每一个渲染树节点的位置和大小，在屏幕上画出渲染树的所有节点。 
          5、将布局绘制（paint）在屏幕上，显示出整个页面完成页面渲染。
         如果DOM树先于CSS规则树构建完成，则在CSS规则树构建完成后，页面会发生一次重绘，将新构建的CSS规则应用于渲染树。
 
## js脚本放在head中
如果把javascript放在head里的话，则先被解析,但这时候body还没有解析，所以会返回空值。一般都会绑定一个监听，当全部的html文档解析完之后，再执行代码：

windows.οnlοad=function(){
      //这里放入执行代码
}

 
   根据问题3衍生问题 4 问题5 问题6
## 4、defer和async浏览器执行时的差别？
       一句话总结async和defer的最主要的区别就是async是异步下载并立即执行，然后文档继续解析，defer是异步加载后解析文档，然后再执行脚本
   
       使用场景看脚本代码是否依赖于页面中的DOM元素，评论框用defer
   
       没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。
       当浏览器遇到 script 标签时，文档的解析不会停止，其他线程将下载脚本，脚本下载完成后立即开始执行脚本，会阻塞HTML渲染，直到脚本执行完毕。
       当浏览器遇到 script 标签时，文档的解析不会停止，其他线程将下载脚本，待到文档渲染完成，脚本才会执行。
  


 
   渲染阻塞的原因？
   
   由于 JavaScript 是可操纵 DOM 的,如果在修改这些元素属性同时渲染界面，那么渲染线程前后获得的元素数据就可能不一致了
   为了防止渲染出现不可预期的结果,浏览器设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系
   当浏览器在执行 JavaScript 程序的时候,GUI 渲染线程会被保存在一个队列中
   如果 JS 执行的时间过长,这样就会造成页面的渲染不连贯,导致页面渲染加载阻塞的感觉
 



 5、DOM Tree与Render Tree之间的区别是什么?
       Dom Tree 包含了所有的HTMl标签，包括display：none，JS动态添加的元素等。
      Dom Tree 和样式结构体结合后构建呈现Render Tree。Render Tree 能识别样式，每个node都有自己的style，且不包含隐藏的节点（比如display:none的节点）。



 

 7、跨域？解决方法？
   跨域：接口请求的地址和当前页面的地址如果协议、域名、端口其中有一项不同，就说该接口跨域
  原因：浏览器为了保证网页的安全，出的同源协议策略。
 跨域解决方案
cors：目前最常用的一种解决办法，通过设置后端允许跨域实现。
res.setHeader('Access-Control-Allow-Origin', '*');
res.setHeader("Access-Control-Allow-Methods", "GET, PUT, OPTIONS, POST");

node中间件、nginx反向代理：跨域限制的时候浏览器不能跨域访问服务器，node中间件和nginx反向代理，都是让请求发给代理服务器，静态页面面和代理服务器是同源的，然后代理服务器再向后端服务器发请求，服务器和服务器之间不存在同源限制。

设置proxy

JSONP：利用的原理是script标签不受同源影响，创建一个script标签, 再把需要请求的api地址放到src里. 这个请求只能用GET方法

postmessage：H5新增API，通过发送和接收API实现跨域通信。
