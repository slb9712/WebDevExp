
  
  1、浏览器输入URL发生了什么？
  
     1、输入url进行查找
     2、浏览器查找当前URL缓存，如果有缓存直接返回给页面，没有缓存则进入网络请求。
     3、DNS解析URL对应的IP地址。（从根域服务器，再向顶级域，二层域最后子域，然后一级一级最后找到域名地址）
     4、根据IP建立TCP(传输控制协议)连接（三次握手）。
     5、合成请求头信息，发起HTTP请求。
     6、服务器处理请求，浏览器接收HTTP响应。
     7、关闭TCP连接（四次挥手）。
     8、构建DOM树，浏览器渲染页面。
 



  根据问题1 衍生问题2问题3
  2、三次握手、四次挥手
  确保建立可靠连接 避免资源浪费
     第一次握手： 建立连接时，客户端发送syn包 连接请求 （syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认； 
     第二次握手： 服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包  确认报文，此时服务器进入SYN_RECV状态；
     第三次握手： 客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。
  
     第三次握手是为了防止已经失效的连接请求报文段突然又传到服务端，防止重复连接
 


 3、浏览器如何渲染页面的？
 ## 浏览器是如何渲染页面的？

当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。

在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。

-------

整个渲染流程分为多个阶段，分别是： HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画

每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。

这样，整个渲染流程就形成了一套组织严密的生产流水线。

-------

渲染的第一步是**解析 HTML**。

解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。

如果主线程解析到`link`位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。

如果主线程解析到`script`位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。

第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。

-------

渲染的下一步是**样式计算**。

主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style。

在这一过程中，很多预设值会变成绝对值，比如`red`会变成`rgb(255,0,0)`；相对单位会变成绝对单位，比如`em`会变成`px`

这一步完成后，会得到一棵带有样式的 DOM 树。

--------

接下来是**布局**，布局完成后会得到布局树。

布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。

大部分时候，DOM 树和布局树并非一一对应。

比如`display:none`的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。

-----------

下一步是**分层**

主线程会使用一套复杂的策略对整个布局树中进行分层。

分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。

滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过`will-change`属性更大程度的影响分层结果。

---------

再下一步是**绘制**

主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。

------

完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。

合成线程首先对每个图层进行分块，将其划分为更多的小区域。

它会从线程池中拿取多个线程来完成分块工作。

----

分块完成后，进入**光栅化**阶段。

合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。

GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。

光栅化的结果，就是一块一块的位图

---------

最后一个阶段就是**画**了

合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。

指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。

变形发生在合成线程，与渲染主线程无关，这就是`transform`效率高的本质原因。

合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。
    1、解析文档构建dom树
     js会交给js引擎处理，css会交给CSS解析器处理。正常情况下， html解析器和css解析器同时进行解析, html解析成一个dom树，解析成dom树的同时，css解析器也会解析成一个css 规则树（ CSSOM ）。在 head 中遇到 JS 文件时，HTML 的解析会停 下来，等 JS 文件下载结束并且执行完，HTML 的解析工作再接着来，防止 JS 修改已经完成的解析结果。
     
           1、HTML 被 HTML 解析器解析成 DOM 树；
           2、CSS：解析样式表，生成CSS规则树
           3、JavaScript：解析脚本，通过DOM API和CSSOM API操作DOM Tree和CSS Rule Tree，与用户进行交互
     2、构建渲染树
           解析文档完成后，浏览器引擎会将 CSS Rule Tree 附着到DOM Tree 上，并根据DOM Tree 和 CSS Rule Tree构造 Rendering Tree（渲染树）
     3、布局与绘制渲染树
           浏览器从服务器获取文档并从上到下进行解析，不包含defer和async属性的情况下，按下面执行
##
           1、解析html文档，遇到HTML标签时，构建DOM树
           2、在构建DOM的过程中，如果遇到外联的样式声明或脚本声明，则暂停文档解析，创建新的网络连接，开始下载样式文件和脚本文件
           3、样式文件下载完成后，构建CSS Rule DOM，脚本文件下载完成后，解释并立即执行。
           4、构建DOM的同时，结合CSS规则树生成渲染树，接着进入布局，遍历生成的 DOM 树节点，并把他们添加到布局树中。浏览器通过解析计算出每一个渲染树节点的位置和大小，在屏幕上画出渲染树的所有节点。 
          5、将布局绘制（paint）在屏幕上，显示出整个页面完成页面渲染。
         如果DOM树先于CSS规则树构建完成，则在CSS规则树构建完成后，页面会发生一次重绘，将新构建的CSS规则应用于渲染树。
## 为什么 transform 的效率高？

因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」阶段

由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。

 
## js脚本放在head中
如果把javascript放在head里的话，则先被解析,但这时候body还没有解析，所以会返回空值。一般都会绑定一个监听，当全部的html文档解析完之后，再执行代码：

windows.οnlοad=function(){
      //这里放入执行代码
}

 
   根据问题3衍生问题 4 问题5 问题6
## 4、defer和async浏览器执行时的差别？
       一句话总结async和defer的最主要的区别就是async是异步下载并立即执行，然后文档继续解析，defer是异步加载后解析文档，然后再执行脚本
   
       使用场景看脚本代码是否依赖于页面中的DOM元素，评论框用defer
   
       没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。
       async,当浏览器遇到 script 标签时，文档的解析不会停止，其他线程将下载脚本，脚本下载完成后立即开始执行脚本，会阻塞HTML渲染，直到脚本执行完毕。
       defer当浏览器遇到 script 标签时，文档的解析不会停止，其他线程将下载脚本，待到文档渲染完成，脚本才会执行。
  


 
   渲染阻塞的原因？
   
   由于 JavaScript 是可操纵 DOM 的,如果在修改这些元素属性同时渲染界面，那么渲染线程前后获得的元素数据就可能不一致了
   为了防止渲染出现不可预期的结果,浏览器设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系
   当浏览器在执行 JavaScript 程序的时候,GUI 渲染线程会被保存在一个队列中
   如果 JS 执行的时间过长,这样就会造成页面的渲染不连贯,导致页面渲染加载阻塞的感觉
 



 5、DOM Tree与Render Tree之间的区别是什么?
       Dom Tree 包含了所有的HTMl标签，包括display：none，JS动态添加的元素等。
      Dom Tree 和样式结构体结合后构建呈现Render Tree。Render Tree 能识别样式，每个node都有自己的style，且不包含隐藏的节点（比如display:none的节点）。



 

 7、跨域？解决方法？
   跨域：接口请求的地址和当前页面的地址如果协议、域名、端口其中有一项不同，就说该接口跨域
  原因：浏览器为了保证网页的安全，出的同源协议策略。
 跨域解决方案
cors：目前最常用的一种解决办法，通过设置后端允许跨域实现。
res.setHeader('Access-Control-Allow-Origin', '*');
res.setHeader("Access-Control-Allow-Methods", "GET, PUT, OPTIONS, POST");

node中间件、nginx反向代理：跨域限制的时候浏览器不能跨域访问服务器，node中间件和nginx反向代理，都是让请求发给代理服务器，静态页面面和代理服务器是同源的，然后代理服务器再向后端服务器发请求，服务器和服务器之间不存在同源限制。

设置proxy

JSONP：利用的原理是script标签不受同源影响，创建一个script标签, 再把需要请求的api地址放到src里. 这个请求只能用GET方法

postmessage：H5新增API，通过发送和接收API实现跨域通信。
