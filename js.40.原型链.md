

> 在JavaScript中是使⽤构造函数来新建⼀个对象的，每⼀个构造函数的内部都有⼀个prototype 属性，它的属性值是⼀个对象，称之为*函数的原型*
> 这个对象包含了 可以由该构造函数的所有实例共享的  属性和⽅法。当使⽤构造函数新建⼀个对象后，新建对象也会有 _proto_ 属性一个隐式原型，指向构造函数原型prototype，在查找对象成员时，若对象本身没有该成员，则会到隐式原型中查找。
> _proto_ 属性（不是语言本身的属性，时浏览器支持的私有属性，不能轻易动，不建议生产时使用，用的话ES5 中新增了⼀个 Object.getPrototypeOf() ⽅法，可以通过这个⽅法来获取对象的原型。）

> 当访问⼀个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对
象⾥找这个属性，这个原型对象⼜会有⾃⼰的原型，于是就这样⼀直找下去，也就是原型
链的概念。

> 原型链的尽头⼀般来说都是 Object.prototype 所以这就是新建的对象为什么
能够使⽤ toString() 等⽅法的原因。
> 特点： JavaScript 对象是通过引⽤来传递的，创建的每个新对象实体中并没有⼀份属于
⾃⼰的原型副本。当修改原型时，会影响到所有实例，与之相关的对象也会继承这⼀改变


每个对象拥有一个原型对象，原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法

在对象实例和它的构造器之间建立一个链接（它是__proto__属性，是从构造函数的prototype属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法

> 当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾

准确地说，这些属性和方法定义在Object的构造器函数（constructor functions）之上的prototype属性上，而非实例对象本身


## 特殊的两个情况
Function的隐式原型指向自己的原型
 Object原型的隐式原型指向null

## 两个固定情况
所有函数的隐式原型，都指向Function的原型（包括Function函数自身）
 所有函数原型的隐式原型，都指向Object的原型。（不包括Object原型对象自身）

## constructor
原型中的constructor指向函数本身