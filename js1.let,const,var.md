## 区别
var 存在变量提升，可以在声明作用域外访问
let const只能块级作用域内访问, 禁止重复声明
const声明必须赋值，let可以先声明在赋值
const声明后不能更改值

## 变量生命周期
引擎访问变量的时候，它们的生命周期包括下面几个阶段：

1. 声明阶段：在作用域中注册一个变量
2. 初始化阶段：分配内存，给作用域中的变量创建绑定。在这个阶段，变量自动地被初始化为undefined
3. 赋值阶段：给已经初始化过的变量赋值

通过声明阶段但是没有到达初始化阶段的变量是处于未定义的状态。 严格来说，提升的概念是在函数作用域的顶部声明和初始化变量。在声明和初始化阶段之间没有间隙。


## 问题
1. 变量提升？

答：变量提升是指var声明的变量和函数会在代码编译期，提升到代码的最前面执行。变量提升的时候声明和初始化阶段被提升，赋值并不会被提升，同时函数的声明提升会比变量的提升优先。变量提升的结果，可以在变量初始化之前访问该变量，返回的是**undefined**。在函数声明前可以调用该函数。使用let和const声明的变量是创建提升，形成暂时性死区，在初始化之前访问let和const创建的变量会报错。在初始化赋值前(before initialization)不允许读取。

2. let const 有没有变量提升？

也存在变量提升，只在变量声明阶段有提升，在初始化阶段没有提升，在声明和初始化之间形成了暂时性死区。解释器进入一个作用域，包含一个`let variable`语句，变量就立刻通过声明阶段，在作用域注册了变量名，还未被初始化，访问的话抛出`ReferenceError: variable is not defined`错误，就是暂时性死区，到达`let variable`的时候被初始化，访问的话是undefined，退出了暂时性死区。在`variable = value`的时候，通过了赋值阶段。

3. 什么是暂时性死区？

let变量的处理方式和var不同。最主要的区别就是声明和初始化阶段被分开了。运行流程进入作用域创建变量，到变量可以被访问之间的这一段时间，就称之为暂时死区。

## 用var模拟let
通过闭包模拟块级作用域
```js
for(var i=1;i<4; i++){
        // 利用函数作用域
        (function f(a){
            setTimeout(function(){
            console.log(a);
        }, 1000);
        })(i);
    }

```


