## 说一说事件循环
执行js代码的时候，遇见同步任务，直接推入调用栈中执行，遇到异步任务，将该任务挂起，等到异步任务有返回之后推入到任务队列中，当调用栈中的所有同步任务全部执行完成，将任务队列中的任务按顺序一个一个的推入并执行，重复执行这一系列的行为。
## 说一说异步任务
异步任务又分为宏任务和微任务。 
1. 宏任务：任务队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列。 
2. 微任务：等宏任务中的主要功能都完成后，渲染引擎不急着去执行下一个宏任务，而是执行当前宏任务中的微任务 
## 说一说常见的宏任务和微任务
1. 宏任务：执行script标签内部代码、setTimeout/setInterval、ajax请、postMessageMessageChannel、setImmediate，I/O（Node.js）
2. 微任务：Promise、MutonObserver、Object.observe、process.nextTick（Node.js）
## 主要运行环境？
1. 浏览器
2. Node.js

## 16ms怎么来的
浏览器通常会尝试每秒渲染60次页面，从而达到每秒60帧的数组。而60fps通常是检验体验是否平滑流畅的标准，比方在动画里——这意味着浏览器会尝试在 16ms 内渲染一帧。

理想情况下，单个任务和该任务附属的所有微任务，都应在 16ms 内完成。

```js
for(var i=0;i<10;i++){
    setTimeout(function(){
      console.log(i);  
    },i*1000);
    }
// 答案：10、10、10、10、10、10、10、10、10、10
// 代码中的for循环是个同步任务，setTimeout是个异步任务，所以把for循环执行完毕后（i=10）才会执行setTimeout（）函数，所以导致输出了10个10的结果
```

setTimeout() 会判断第一个参数是否是[function]，如果是，则执行异步任务。如果不是，则会尝试将它当做字符串处理。所以第二段代码setTimeout里面的function被当成异步任务不会立刻执行，而是被放入任务队列。