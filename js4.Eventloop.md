## 何为进程？
程序运行需要有它自己专属的内存空间，可以把这块内存空间简单的理解为进程
## 单线程 和 异步
> JS特点就是单线程，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。而渲染主线程承担着诸多的工作，渲染页面、执行 JS 都在其中运行
> 如果使用同步的方式，其在同一个时间内只能做一件事。就极有可能导致主线程产生阻塞，> 从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。
> 所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。
> 在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。

## 为什么js是单线程？
> 作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，会带来很复杂的线程同步问题

## 任务有优先级吗？
> 任务没有优先级，在消息队列中先进先出

## 如何处理异步操作, 不用等待
js 引擎执行异步代码而不用等待，是因有为有 *消息队列* 和  *事件循环*。
1. 消息队列：消息队列是一个先进先出的队列，它里面存放着各种消息。
2. 事件循环：事件循环是指主线程重复从消息队列中取消息、执行的过程。

## 说一说事件循环
> 事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。
> 过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。

在目前 chrome 的实现中，至少包含了下面的队列：

- 延时队列：用于存放计时器到达后的回调任务，优先级「中」
- 交互队列：用于存放用户操作后产生的事件处理任务，点击操作，优先级「高」
- 微队列：用户存放需要最快执行的任务，优先级「最高」

```js

//添加任务到微队列的主要方式主要是使用 Promise、MutationObserver
//例如：
 // 立即把一个函数添加到微队列
    Promise.resolve().then(函数)

```
> 根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。

执行js代码的时候，遇见同步任务，直接推入调用栈中执行，遇到异步任务，将该任务挂起，等到异步任务有返回之后推入到任务队列中，当调用栈中的所有同步任务全部执行完成，将任务队列中的任务按顺序一个一个的推入并执行，重复执行这一系列的行为。
## 说一说异步任务
异步任务又分为宏任务和微任务。 
1. 宏任务：任务队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列。 
2. 微任务：等宏任务中的主要功能都完成后，渲染引擎不急着去执行下一个宏任务，而是执行当前宏任务中的微任务 
## 说一说常见的宏任务和微任务
1. 宏任务：执行script标签内部代码、setTimeout/setInterval、ajax请、postMessageMessageChannel、setImmediate，I/O（Node.js）
2. 微任务：Promise、MutonObserver、Object.observe、process.nextTick（Node.js）
## 主要运行环境？
1. 浏览器
2. Node.js
## JS 中的计时器能做到精确计时吗？为什么？

> 不行，因为：
>
> 1. 计算机硬件没有原子钟，无法做到精确计时
> 2. 操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调用的是操作系统的函数，也就携带了这些偏差
> 3. 按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 4 毫秒的最少时间，这样在计时时间少于 4 毫秒时又带来了偏差
> 4. 受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差
## 16ms怎么来的
浏览器通常会尝试每秒渲染60次页面，从而达到每秒60帧的数组。而60fps通常是检验体验是否平滑流畅的标准，比方在动画里——这意味着浏览器会尝试在 16ms 内渲染一帧。

理想情况下，单个任务和该任务附属的所有微任务，都应在 16ms 内完成。

```js
for(var i=0;i<10;i++){
    setTimeout(function(){
      console.log(i);  
    },i*1000);
    }
// 答案：10、10、10、10、10、10、10、10、10、10
// 代码中的for循环是个同步任务，setTimeout是个异步任务，所以把for循环执行完毕后（i=10）才会执行setTimeout（）函数，所以导致输出了10个10的结果
```

setTimeout() 会判断第一个参数是否是[function]，如果是，则执行异步任务。如果不是，则会尝试将它当做字符串处理。所以第二段代码setTimeout里面的function被当成异步任务不会立刻执行，而是被放入任务队列。

## 浏览器有哪些进程和线程
**浏览器是一个多进程多线程的应用程序**

主要的进程有：

1. 浏览器进程

   主要负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务。

2. 网络进程

   负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务。

3. **渲染进程**（重点）

   渲染进程启动后，会开启一个**渲染主线程**，主线程负责执行 HTML、CSS、JS 代码。

   默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间不相互影响。

### 渲染主线程是如何工作的？

渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于：

- 解析 HTML
- 解析 CSS
- 计算样式
- 布局
- 处理图层
- 每秒把页面画 60 次
- 执行全局 JS 代码
- 执行事件处理函数
- 执行计时器的回调函数
- ......